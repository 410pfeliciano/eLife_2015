%Processing of position data and decoding

%prerequisite data:
% epoch = [epoch_starttime, epoch_endtime] : selected behavioral epoch
% txy, xy : time vector and (x,y) animal position array
% spike_times : cell array with spike time vector for each tetrode
% spike_amplitudes : cell array with spike amplitude array for each tetrode
% cluster_spike_times : cell array with spike time vector for each cluster
% swr_segments : array with sharp-wave ripple event start and end times

%step 1: manually define track layout from overhead video image
%  the track is described by a set of vertices (end points and choice points)
%  and by a set of polylines that connect the vertices

%  example:

track = struct('type','complex_track',...
	           'info',struct('name','complex track', ...
	                  'vertices',[39.500784 41.2665124674393;139.959568 31.5132324674393;138.008912 161.231856467439;35.599472 156.355216467439;237.492368 41.2665124674393;235.541712 154.404560467439], ...
					  'vertex_labels',{{'vertex1';'vertex2';'vertex3';'vertex4';'vertex5';'vertex6'}}, ...
					  'polylines',{{struct('type','shapes.shape_polyline','name','polyline','nodes',[237.492368 41.2665124674393;139.959568 31.5132324674393],'isclosed',false,'isspline',false,'nodelimit',[0 Inf]), ...
					                struct('type','shapes.shape_polyline','name','polyline','nodes',[39.500784 41.2665124674393;139.959568 31.5132324674393],'isclosed',false,'isspline',false,'nodelimit',[0 Inf]), ...
						      	    struct('type','shapes.shape_polyline','name','polyline','nodes',[139.959568 31.5132324674393;138.008912 161.231856467439],'isclosed',false,'isspline',false,'nodelimit',[0 Inf]), ...
								    struct('type','shapes.shape_polyline','name','polyline','nodes',[138.008912 161.231856467439;35.599472 156.355216467439],'isclosed',false,'isspline',false,'nodelimit',[0 Inf]), ...
								    struct('type','shapes.shape_polyline','name','polyline','nodes',[138.008912 161.231856467439;235.541712 154.404560467439],'isclosed',false,'isspline',false,'nodelimit',[0 Inf])}}));


%step 2: linearize selected 2D position data

selection = txy>epoch(1) & txy<epoch(2);
txy = txy(selection,1);
xy = xy(selection,:);

linear_position = track.linearize( xy );


%step 3: compute linearized velocity, running direction and determine run segments

linear_velocity = smoothn( track.velocity( linear_position ), 0.25, 1/30 );
direction = sign(linear_velocity);
VELOCITY_THRESHOLD = 10; %in cm/s
run_segments = logical2seg( txy, abs(linear_velocity)>VELOCITY_THRESHOLD );


%step 4: discretize linear position and compute distance look-up table
%  to compute the kernel density estimate of the joint spike amplitude and position distribution during decoding
%  we need to compute the distance between locations on the linearized track
%  given that the track has choice points, we cannot use the euclidean distance in linearized space
%  so we will instead finely discretize the linearized position and
%  compute a distance look-up table

discrete_x = 0:0.25:track.length; %discretize at 0.25 cm intervals
tmp = repmat( discrete_x, numel(discrete_x), 1 );
tmp = abs( track.lineardistance( tmp, tmp' ) ); % compute shortest distance along track between pairs of locations
distance_lut = reshape( tmp, [1 1].*numel(distance_x) );


%step 5: convert linear position to discretized position

linear_position = interp1( discrete_x, 0:numel(discrete_x)-1, linear_position, 'nearest', 'extrap' );

[decoding_grid, nbins] = track.bin(10);
decoding_grid = interp1( discrete_x, 0:numel(discrete_x)-1, decoding_grid, 'nearest', 'extrap'  );

spike_position = cellfun( @(x) interp1( txy, linear_position, x, 'nearest' ), spike_times, 'UniformOutput', false );


%step 6: cross-validation of position decoding performance during running

%  define training and test data.
%  first divide epoch into 0.5 seconds bins
segments = seg2bin( txy([1 end])', 'binsize', 0.5 );
%  then select one half for training and the other half for testing
training_segments = seg_and( run_segments, segments(1:2:end,:) );
test_segments = seg_and( run_segments, segments(2:2:end,:) );

%  perform clusterless position decoding
%  (decoding code not included - see Kloosterman et al., 2014 for instructions)

%  only spikes that have a peak-to-trough width of at least 250 microseconds
%  and an peak amplitude of at least 100 microVolt are used for decoding

decoder = kde_decoder( txy, linear_position, spike_times, spike_position, spike_amplitudes, ...
     'encoding_segments', training_segments, ...
     'distance', {distance_lut}, ...
     'stimulus_variable_type', 'linear', ...
     'stimulus_kernel', 'epanechnikov', ...
     'stimulus_bandwidth', 10, ...
     'response_variable_type', 'linear', ...
     'response_kernel', 'epanechnikov', ...
     'response_bandwidth', 0.05 , ...
     'stimulus_grid', {decoding_grid});        

[posterior, error] = decoder.compute(test_segments);

%  for comparison with decoding with manual clustered data:

cluster_spike_position = cellfun( @(x) interp1( txy, linear_position, x, 'nearest' ), cluster_spike_times, 'UniformOutput', false );

decoder_cl = kde_decoder( txy, linear_position, cluster_spike_times, cluster_spike_position,  ...
     'encoding_segments', training_segments, ...
     'distance', {distance_lut}, ...
     'stimulus_variable_type', 'linear', ...
     'stimulus_kernel', 'epanechnikov', ...
     'stimulus_bandwidth', 10, ...
     'response_variable_type', [], ...
     'response_kernel', 'epanechnikov', ...
     'response_bandwidth', [] , ...
     'stimulus_grid', {decoding_grid});        

[posterior_cl, error_cl] = decoder_cl.compute(test_segments);


%step 7: cross-validation of direction decoding performance during running

% now reconstuct direction 
spike_direction = cellfun( @(x) interp1( txy, direction, x, 'nearest' ), spike_times, 'UniformOutput', false );

decoder = kde_decoder( txy, direction, spike_times, spike_direction, spike_amplitudes, ...
     'encoding_segments', training_segments, ...
     'distance', {[]}, ...
     'stimulus_variable_type', {'categorical'}, ...
     'stimulus_kernel', {'kronecker'}, ...
     'stimulus_bandwidth', 0.5, ...
     'response_variable_type', 'linear', ... 
     'response_kernel', 'epanechnikov', ...
     'response_bandwidth', 0.05 , ...
     'stimulus_grid', {[-1 1]});
	 
[posterior, error] = decoder.compute(test_segments);


%step 8: position decoding during sharp-wave ripple events

decoder = kde_decoder( txy, linear_position, spike_times, spike_position, spike_amplitudes, ...
     'encoding_segments', run_segments, ...
     'distance', {distance_lut}, ...
     'stimulus_variable_type', 'linear', ...
     'stimulus_kernel', 'epanechnikov', ...
     'stimulus_bandwidth', 10, ...
     'response_variable_type', 'linear', ...
     'response_kernel', 'epanechnikov', ...
     'response_bandwidth', 0.05 , ...
     'stimulus_grid', {decoding_grid});        

[swr_bins, swr_nbins] = seg2bin( swr_segments, 'binsize', 0.025 );
posterior = decoder.compute( swr_bins );


%step 9: direction decoding during sharp-wave ripple events

decoder = kde_decoder( txy, direction, spike_times, spike_direction, spike_amplitudes, ...
     'encoding_segments', drun_segments, ...
     'distance', {[]}, ...
     'stimulus_variable_type', {'categorical'}, ...
     'stimulus_kernel', {'kronecker'}, ...
     'stimulus_bandwidth', 0.5, ...
     'response_variable_type', 'linear', ... 
     'response_kernel', 'epanechnikov', ...
     'response_bandwidth', 0.05 , ...
     'stimulus_grid', {[-1 1]});

posterior = decoder.compute( swr_bins );
